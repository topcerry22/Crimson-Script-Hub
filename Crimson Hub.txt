local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Crimson Hub",
   LoadingTitle = "Crimson Hub",
   LoadingSubtitle = "by RACECARGAMING559",
   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Example Hub"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Key System",
      Subtitle = "",
      Note = "Key In Discord Server",
      FileName = "YoutubeHubKey1", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = True, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"SIGMACITY"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})


Window.ModifyTheme('Amethyst')

local MainTab1 = Window:CreateTab("Universal", nil) -- Title, Image
local MainSection = MainTab1:CreateSection("Main")

local MainTab2 = Window:CreateTab("Prison Life", nil) -- Title, Image
local MainSection = MainTab2:CreateSection("Teleports")

local MainTab3 = Window:CreateTab("Murder Mystery 2", nil) -- Title, Image
local MainSection = MainTab3:CreateSection("Main")


local Button = MainTab1:CreateButton({
   Name = "Infinite Jump Toggle",
   Callback = function()
       --Toggles the infinite jump between on or off on every script run
_G.infinjump = not _G.infinjump

if _G.infinJumpStarted == nil then
	--Ensures this only runs once to save resources
	_G.infinJumpStarted = true
	
	--Notifies readiness
	game.StarterGui:SetCore("SendNotification", {Title="Youtube Hub"; Text="Infinite Jump Activated!"; Duration=5;})

	--The actual infinite jump
	local plr = game:GetService('Players').LocalPlayer
	local m = plr:GetMouse()
	m.KeyDown:connect(function(k)
		if _G.infinjump then
			if k:byte() == 32 then
			humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
			humanoid:ChangeState('Jumping')
			wait()
			humanoid:ChangeState('Seated')
			end
		end
	end)
end
   end,
})
local Button = MainTab1:CreateButton({
   Name = "Fly Script",
   Callback = function()
   	-- FlyScript (LocalScript)
-- Place in StarterPlayer > StarterPlayerScripts
-- Works for dev/testing in your own game

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local cam = workspace.CurrentCamera

-- Config
local TOGGLE_KEY = Enum.KeyCode.F
local ASCEND_KEY = Enum.KeyCode.Space
local DESCEND_KEY = Enum.KeyCode.LeftControl
local MOVE_SPEED = 80         -- studs/second (base)
local ASCEND_SPEED = 60       -- studs/second when holding ascend key
local ACCELERATION = 12       -- higher = snappier velocity changes
local MAX_FORCE = 1e5         -- applied to BodyVelocity / BodyGyro

-- Internal state
local flying = false
local bv, bg
local char, hrp, humanoid
local inputState = {
	forward = 0,
	right = 0,
	up = 0,
}

-- Utility: create flight objects attached to HumanoidRootPart
local function createFlightObjects(root)
	-- BodyVelocity
	local bvInst = Instance.new("BodyVelocity")
	bvInst.MaxForce = Vector3.new(MAX_FORCE, MAX_FORCE, MAX_FORCE)
	bvInst.Velocity = Vector3.new()
	bvInst.P = 1250
	bvInst.Name = "Fly_BodyVelocity"
	bvInst.Parent = root

	-- BodyGyro to stabilize orientation (optional)
	local bgInst = Instance.new("BodyGyro")
	bgInst.MaxTorque = Vector3.new(MAX_FORCE, MAX_FORCE, MAX_FORCE)
	bgInst.P = 3000
	bgInst.D = 50
	bgInst.Name = "Fly_BodyGyro"
	bgInst.Parent = root

	return bvInst, bgInst
end

local function cleanupFlightObjects()
	if bv then
		pcall(function() bv:Destroy() end)
		bv = nil
	end
	if bg then
		pcall(function() bg:Destroy() end)
		bg = nil
	end
end

-- Toggle flying on/off
local function setFlying(state)
	if not char or not hrp or not humanoid then return end
	if state == flying then return end
	flying = state

	if flying then
		-- create objects
		cleanupFlightObjects()
		bv, bg = createFlightObjects(hrp)
		-- optional: reduce humanoid gravity effects by switching state
		-- But avoid fully disabling animations in case you want them.
		-- We'll also disable collisions with PlatformStand approach:
		humanoid.PlatformStand = true
	else
		-- cleanup
		humanoid.PlatformStand = false
		cleanupFlightObjects()
		-- zero out any residual velocity on server (local-only effect mostly)
		hrp.AssemblyLinearVelocity = Vector3.new()
	end
end

-- Input handling (movement axes)
local function onInputBegan(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local k = input.KeyCode
		if k == TOGGLE_KEY then
			setFlying(not flying)
		elseif k == ASCEND_KEY then
			inputState.up = 1
		elseif k == DESCEND_KEY then
			inputState.up = -1
		elseif k == Enum.KeyCode.W or k == Enum.KeyCode.Up then
			inputState.forward = 1
		elseif k == Enum.KeyCode.S or k == Enum.KeyCode.Down then
			inputState.forward = -1
		elseif k == Enum.KeyCode.A or k == Enum.KeyCode.Left then
			inputState.right = -1
		elseif k == Enum.KeyCode.D or k == Enum.KeyCode.Right then
			inputState.right = 1
		end
	end
end

local function onInputEnded(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local k = input.KeyCode
		if k == ASCEND_KEY or k == DESCEND_KEY then
			inputState.up = 0
		elseif k == Enum.KeyCode.W or k == Enum.KeyCode.Up or k == Enum.KeyCode.S or k == Enum.KeyCode.Down then
			inputState.forward = 0
		elseif k == Enum.KeyCode.A or k == Enum.KeyCode.Left or k == Enum.KeyCode.D or k == Enum.KeyCode.Right then
			inputState.right = 0
		end
	end
end

-- Main update loop when flying
local currentVelocity = Vector3.new()
local function onRenderStep(dt)
	if not flying or not hrp or not bv or not bg or not cam then return end

	-- Camera relative move vectors
	local camCFrame = cam.CFrame
	local forward = camCFrame.LookVector
	local right = camCFrame.RightVector

	-- Remove vertical from forward/right to keep horizontal direction based on camera yaw
	forward = Vector3.new(forward.X, 0, forward.Z).Unit
	if forward ~= forward then forward = Vector3.new(0,0,-1) end -- safe fallback
	right = Vector3.new(right.X, 0, right.Z).Unit
	if right ~= right then right = Vector3.new(1,0,0) end

	local moveDir = (forward * inputState.forward) + (right * inputState.right)
	if moveDir.Magnitude > 0 then
		moveDir = moveDir.Unit
	end

	local targetHorizontal = moveDir * MOVE_SPEED
	local verticalSpeed = inputState.up * ASCEND_SPEED
	local target = Vector3.new(targetHorizontal.X, verticalSpeed, targetHorizontal.Z)

	-- Smooth velocity interpolation
	local alpha = math.clamp(ACCELERATION * dt, 0, 1)
	currentVelocity = currentVelocity:Lerp(target, alpha)

	-- Apply to BodyVelocity
	bv.Velocity = currentVelocity

	-- Stabilize rotation to face camera forward (optional)
	local lookDir = CFrame.new(hrp.Position, hrp.Position + camCFrame.LookVector)
	bg.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, lookDir:ToEulerAnglesYXZ())
end

-- Character handling
local function onCharacterAdded(c)
	char = c
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")

	-- Ensure flying off when respawned
	flying = false
	cleanupFlightObjects()

	-- Optional: stop flying on death
	humanoid.Died:Connect(function()
		setFlying(false)
	end)
end

-- Bindings
player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
	onCharacterAdded(player.Character)
end

UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)
RunService:BindToRenderStep("FlyScript_Render", Enum.RenderPriority.Character.Value, onRenderStep)

-- Cleanup on leave / script disable
script.Disabled = false
script.Destroying:Connect(function()
	setFlying(false)
	RunService:UnbindFromRenderStep("FlyScript_Render")
	cleanupFlightObjects()
end)

   end,
})
local Button = MainTab1:CreateButton({
   Name = "Touch Fling GUI",
   Callback = function()
   	-- Touch fling gui
 
-- Gui to Lua (VIP VERSION)
-- Version: 6.9
 
-- Instances:
 
local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local Frame_2 = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local TextButton = Instance.new("TextButton")
 
--Properties:
 
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false
print("sub to BlueCat")
 
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(34, 34, 34)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.388539821, 0, 0.427821517, 0)
Frame.Size = UDim2.new(0, 158, 0, 110)
 
Frame_2.Parent = Frame
Frame_2.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderSizePixel = 0
Frame_2.Size = UDim2.new(0, 158, 0, 25)
 
TextLabel.Parent = Frame_2
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(0.112792775, 0, -0.0151660154, 0)
TextLabel.Size = UDim2.new(0, 121, 0, 26)
TextLabel.Font = Enum.Font.Sarpanch
TextLabel.Text = "Touch Fling"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 255)
TextLabel.TextSize = 25.000
 
TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BorderSizePixel = 0
TextButton.Position = UDim2.new(0.113924049, 0, 0.418181807, 0)
TextButton.Size = UDim2.new(0, 121, 0, 37)
TextButton.Font = Enum.Font.SourceSansItalic
TextButton.Text = "OFF"
TextButton.TextColor3 = Color3.fromRGB(0, 0, 0)
TextButton.TextSize = 20.000
 
-- Scripts:
 
local function IIMAWH_fake_script() -- TextButton.LocalScript 
	local script = Instance.new('LocalScript', TextButton)
 
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
 
	local toggleButton = script.Parent
	local hiddenfling = false
	local flingThread 
	if not ReplicatedStorage:FindFirstChild("juisdfj0i32i0eidsuf0iok") then
		local detection = Instance.new("Decal")
		detection.Name = "juisdfj0i32i0eidsuf0iok"
		detection.Parent = ReplicatedStorage
	end
 
	local function fling()
		local lp = Players.LocalPlayer
		local c, hrp, vel, movel = nil, nil, nil, 0.1
 
		while hiddenfling do
			RunService.Heartbeat:Wait()
			c = lp.Character
			hrp = c and c:FindFirstChild("HumanoidRootPart")
 
			if hrp then
				vel = hrp.Velocity
				hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
				RunService.RenderStepped:Wait()
				hrp.Velocity = vel
				RunService.Stepped:Wait()
				hrp.Velocity = vel + Vector3.new(0, movel, 0)
				movel = -movel
			end
		end
	end
 
	toggleButton.MouseButton1Click:Connect(function()
		hiddenfling = not hiddenfling
		toggleButton.Text = hiddenfling and "ON" or "OFF"
 
		if hiddenfling then
			flingThread = coroutine.create(fling)
			coroutine.resume(flingThread)
		else
			hiddenfling = false
		end
	end)
 
end
coroutine.wrap(IIMAWH_fake_script)()
local function QCJQJL_fake_script() -- Frame.LocalScript 
	local script = Instance.new('LocalScript', Frame)
 
	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(QCJQJL_fake_script)()
   end,
})
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local forceField -- will hold ForceField instance
local godmodeActive = false


local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

local Input = MainTab1:CreateInput({
    Name = "WalkSpeed",
    CurrentValue = "",
    PlaceholderText = "Enter WalkSpeed",
    RemoveTextAfterFocusLost = false,
    Flag = "WalkSpeedInput",
    Callback = function(Text)
        local speed = tonumber(Text)
        if speed then
            -- Apply the WalkSpeed to the Humanoid
            local char = player.Character
            if char and char:FindFirstChild("Humanoid") then
                char.Humanoid.WalkSpeed = speed
            end
        else
            warn("Invalid number entered for WalkSpeed!")
        end
    end,
})
local player = game.Players.LocalPlayer

local Input = MainTab1:CreateInput({
    Name = "JumpPower",
    CurrentValue = "",
    PlaceholderText = "Enter JumpPower",
    RemoveTextAfterFocusLost = false,
    Flag = "JumpPowerInput",
    Callback = function(Text)
        local jumpPower = tonumber(Text)
        if jumpPower then
            -- Apply JumpPower to your character
            local char = player.Character or player.CharacterAdded:Wait()
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.JumpPower = jumpPower
            end
        else
            warn("Invalid number entered for JumpPower!")
        end
    end,
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local espObjects = {} -- table to store ESP info

local Toggle = MainTab1:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Flag = "ESPNametags",
    Callback = function(Value)
        if Value then
            -- Enable ESP for existing players
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= player and p.Character then
                    local char = p.Character
                    -- Highlight
                    if not espObjects[p] then
                        local highlight = Instance.new("Highlight")
                        highlight.Adornee = char
                        highlight.FillColor = Color3.fromRGB(0, 255, 0)
                        highlight.FillTransparency = 0.5
                        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                        highlight.OutlineTransparency = 0
                        highlight.Parent = game:GetService("CoreGui")

                        -- NameTag
                        local nameTag = Instance.new("BillboardGui")
                        nameTag.Name = "ESPNameTag"
                        nameTag.Adornee = char:FindFirstChild("HumanoidRootPart")
                        nameTag.Size = UDim2.new(0,100,0,40)
                        nameTag.StudsOffset = Vector3.new(0,3,0)
                        nameTag.AlwaysOnTop = true

                        local label = Instance.new("TextLabel")
                        label.Size = UDim2.new(1,0,1,0)
                        label.BackgroundTransparency = 1
                        label.Text = p.Name
                        label.TextColor3 = Color3.fromRGB(0,255,0)
                        label.TextScaled = true
                        label.Font = Enum.Font.SourceSansBold
                        label.Parent = nameTag

                        nameTag.Parent = game:GetService("CoreGui")

                        espObjects[p] = {highlight = highlight, nameTag = nameTag}
                    end
                end
            end

            -- Track new players joining
            Players.PlayerAdded:Connect(function(p)
                if Value and p ~= player then
                    p.CharacterAdded:Connect(function(char)
                        if not espObjects[p] then
                            local highlight = Instance.new("Highlight")
                            highlight.Adornee = char
                            highlight.FillColor = Color3.fromRGB(0, 255, 0)
                            highlight.FillTransparency = 0.5
                            highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                            highlight.OutlineTransparency = 0
                            highlight.Parent = game:GetService("CoreGui")

                            local nameTag = Instance.new("BillboardGui")
                            nameTag.Name = "ESPNameTag"
                            nameTag.Adornee = char:FindFirstChild("HumanoidRootPart")
                            nameTag.Size = UDim2.new(0,100,0,40)
                            nameTag.StudsOffset = Vector3.new(0,3,0)
                            nameTag.AlwaysOnTop = true

                            local label = Instance.new("TextLabel")
                            label.Size = UDim2.new(1,0,1,0)
                            label.BackgroundTransparency = 1
                            label.Text = p.Name
                            label.TextColor3 = Color3.fromRGB(0,255,0)
                            label.TextScaled = true
                            label.Font = Enum.Font.SourceSansBold
                            label.Parent = nameTag

                            nameTag.Parent = game:GetService("CoreGui")

                            espObjects[p] = {highlight = highlight, nameTag = nameTag}
                        end
                    end)
                end
            end)

        else
            -- Disable ESP + NameTags
            for _, objs in pairs(espObjects) do
                if objs.highlight then objs.highlight:Destroy() end
                if objs.nameTag then objs.nameTag:Destroy() end
            end
            espObjects = {}
        end
    end,
})

local player = game.Players.LocalPlayer

-- Set the target location here
local targetPosition = Vector3.new(827, 99, 2242) -- Change this to your desired coordinates

local Button = MainTab2:CreateButton({
    Name = "Teleport to Office",
    Callback = function()
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(targetPosition)
            print("Teleported to: ", targetPosition)
        else
            warn("HumanoidRootPart not found!")
        end
    end,
})
local player = game.Players.LocalPlayer

-- Set the target location here
local targetPosition = Vector3.new(-930, 94, 2061) -- Change this to your desired coordinates

local Button = MainTab2:CreateButton({
    Name = "Teleport to Hideout",
    Callback = function()
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(targetPosition)
            print("Teleported to: ", targetPosition)
        else
            warn("HumanoidRootPart not found!")
        end
    end,
})

local MainSection2 = MainTab2:CreateSection("Police")

local Input = MainTab2:CreateInput({
    Name = "Arrest Player",
    CurrentValue = "",
    PlaceholderText = "Enter player name or display name",
    RemoveTextAfterFocusLost = false,
    Flag = "Input1",
    Callback = function(Text)
        -- Everything runs inside here
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local localPlayer = Players.LocalPlayer

        if Text == "" then return end
        Text = string.lower(Text)

        -- Find by username or display name (partial supported)
        local targetPlayer = nil
        for _, player in pairs(Players:GetPlayers()) do
            local uname = string.lower(player.Name)
            local dname = string.lower(player.DisplayName)
            if uname:find(Text) or dname:find(Text) then
                targetPlayer = player
                break
            end
        end

        if not targetPlayer or targetPlayer == localPlayer then

            return
        end

        -- Wait for humanoid root parts
        local function waitForHRP(player)
            local char = player.Character or player.CharacterAdded:Wait()
            return char:WaitForChild("HumanoidRootPart", 5)
        end

        local localChar = localPlayer.Character or localPlayer.CharacterAdded:Wait()
        local localHRP = localChar:WaitForChild("HumanoidRootPart")

        local origCFrame = localHRP.CFrame

        local targetHRP = waitForHRP(targetPlayer)
        if not targetHRP then
            warn("Target HumanoidRootPart not found.")
            return
        end

        -- Teleport to target for 3 seconds
        local DURATION = 3
        local OFFSET = Vector3.new(0, 0, 5)
        local startTime = tick()

        while tick() - startTime < DURATION do
            if not targetHRP.Parent then break end
            if not localHRP or not localHRP.Parent then break end
            localHRP.CFrame = targetHRP.CFrame * CFrame.new(OFFSET)
            RunService.Heartbeat:Wait()
        end

        -- Return to original location
        if localHRP and localHRP.Parent then
            localHRP.CFrame = origCFrame
        end
    end,
})
local Button = MainTab1:CreateButton({
   Name = "Godmode",
   Callback = function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- GLOBAL state to handle multiple runs
_G.GodMode = _G.GodMode or {}
local state = _G.GodMode

if state.enabled then
    -- Disable GodMode
    if state.connection then
        state.connection:Disconnect()
        state.connection = nil
    end

    -- Remove ForceField if exists
    local ff = character:FindFirstChild("AdminForceField")
    if ff then
        ff:Destroy()
    end

    state.enabled = false
    print("[GodMode] Disabled")
else
    -- Enable GodMode
    state.enabled = true

    -- Add ForceField
    local ff = Instance.new("ForceField")
    ff.Name = "AdminForceField"
    ff.Parent = character

    -- Keep health full every heartbeat
    state.connection = RunService.Heartbeat:Connect(function()
        if humanoid and humanoid.Health > 0 then
            humanoid.Health = humanoid.MaxHealth
        end
    end)

    print("[GodMode] Enabled")
end

   end,
})

local MainSection = MainTab2:CreateSection("Main")



local MainTab4 = Window:CreateTab("Work at a pizza place", nil) -- Title, Image
local MainSection = MainTab4:CreateSection("Main")


local Button = MainTab4:CreateButton({
   Name = "Steal Manager Spot",
   Callback = function()
-- TeleportWhenTeamEmpty.lua
-- LocalScript (client)
-- Teleports the local player to TELEPORT_POSITION when TARGET_TEAM_NAME has no players.
-- Adjust settings below.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TeamsService = game:GetService("Teams") -- optional if you prefer Team objects

local LocalPlayer = Players.LocalPlayer

-- CONFIG:
local TARGET_TEAM_NAME = "Manager" -- team name to watch (case-sensitive)
local TELEPORT_POSITION = Vector3.new(23.58, 4.18, 6.46) -- where to teleport when team is empty
local CHECK_INTERVAL = 1 -- seconds between checks
local DEBOUNCE_TIME = 3 -- seconds to wait after teleport before allowing teleport again (prevents spam)

-- Optional: only teleport if the local player is not already on that team
local SKIP_IF_ON_TARGET_TEAM = true

-- Internal
local lastTeleport = 0

local function getTeamByName(name)
    if not name then return nil end
    for _, t in pairs(TeamsService:GetChildren()) do
        if t:IsA("Team") and t.Name == name then
            return t
        end
    end
    return nil
end

local function teamPlayerCount(team)
    if not team then return 0 end
    local count = 0
    for _, p in pairs(Players:GetPlayers()) do
        if p.Team == team then
            count = count + 1
        end
    end
    return count
end

local function teleportLocalPlayerTo(pos)
    local char = LocalPlayer.Character
    if not char then return false end

    local hrp = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
    if not hrp then return false end

    -- Use SetPrimaryPartCFrame if PrimaryPart exists, otherwise set HRP.CFrame
    if char.PrimaryPart then
        char:SetPrimaryPartCFrame(CFrame.new(pos) * CFrame.new(0, 2, 0)) -- slight upward offset
    else
        hrp.CFrame = CFrame.new(pos) * CFrame.new(0, 2, 0)
    end

    lastTeleport = tick()
    return true
end

-- main loop
spawn(function()
    -- Wait until player and character exist
    while not LocalPlayer do
        wait()
    end

    -- resolve team object if provided by name
    local targetTeam = getTeamByName(TARGET_TEAM_NAME)

    while true do
        local now = tick()

        -- If team object might change (e.g., team created late), keep resolving by name
        if not targetTeam then
            targetTeam = getTeamByName(TARGET_TEAM_NAME)
        end

        -- Optionally skip if local player is on that team
        if SKIP_IF_ON_TARGET_TEAM and targetTeam and LocalPlayer.Team == targetTeam then
            -- do nothing
        else
            local count = teamPlayerCount(targetTeam)
            if count == 0 then
                -- check debounce
                if now - lastTeleport > DEBOUNCE_TIME then
                    local success = teleportLocalPlayerTo(TELEPORT_POSITION)
                    if success then
                        -- optional: notify the local admin player
                        pcall(function()
                            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                                Text = "[AutoTeleport] Team '".. tostring(TARGET_TEAM_NAME) .."' empty. Teleported.";
                                Color = Color3.fromRGB(100, 255, 100);
                                Font = Enum.Font.SourceSansBold;
                                FontSize = Enum.FontSize.Size24;
                            })
                        end)
                    end
                end
            end
        end

        wait(CHECK_INTERVAL)
    end
end)


   end,
})

local Toggle = MainTab2:CreateToggle({
   Name = "(Debugging)Aimbot",
   CurrentValue = false,
   Flag = "Toggle133",
   Callback = function(Value)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local Workspace = game:GetService("Workspace")

        -- Ensure game and local player are loaded
        if not game:IsLoaded() then game.Loaded:Wait() end
        local localPlayer = Players.LocalPlayer
        if not localPlayer then
            warn("LocalPlayer not found.")
            return
        end

        -- Wait for camera to exist
        local camera = Workspace.CurrentCamera
        if not camera then
            camera = Workspace:GetPropertyChangedSignal("CurrentCamera"):Wait()
        end

        -- CONFIG
        local FOV_DEGREES = 40
        local MAX_DISTANCE = 2000
        local SMOOTHNESS = 8
        local TEAM_CHECK = true
        local PREDICT = false
        local BULLET_SPEED = 200
        local REQUIRE_LOS = true -- line-of-sight check

        local aimConnection
        local charAddedConn
        local currentHumanoid

        -- Update references to character/humanoid/camera (safe)
        local function updateCharacterReferences()
            -- wait for character if it doesn't exist yet
            local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
            currentHumanoid = char:FindFirstChildOfClass("Humanoid")
            -- ensure camera reference
            camera = Workspace.CurrentCamera or Workspace:GetPropertyChangedSignal("CurrentCamera"):Wait()
        end

        -- Utility: get R6 torso
        local function getR6TargetPart(player)
            if not player or not player.Character then return nil end
            local char = player.Character
            return char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso") or char.PrimaryPart
        end

        -- Wall check: returns true if visible
        local function hasLineOfSight(targetPart)
            if not targetPart or not camera then return false end
            local origin = camera.CFrame.Position
            local direction = targetPart.Position - origin
            if direction.Magnitude <= 0 then return false end

            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {}
            if localPlayer.Character then
                table.insert(raycastParams.FilterDescendantsInstances, localPlayer.Character)
            end
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

            local result = Workspace:Raycast(origin, direction, raycastParams)
            if result then
                return result.Instance:IsDescendantOf(targetPart.Parent)
            else
                return true
            end
        end

        -- Closest valid target
        local function getClosestTargetR6()
            if not camera then return nil end
            local camPos = camera.CFrame.Position
            local camLook = camera.CFrame.LookVector
            local best, bestAngle, bestDist = nil, math.huge, math.huge

            for _, p in pairs(Players:GetPlayers()) do
                if p ~= localPlayer and p.Character and p.Character.Parent then
                    if TEAM_CHECK then
                        local myTeam = localPlayer.Team
                        if myTeam and p.Team == myTeam then
                            goto continue
                        end
                    end
                    local part = getR6TargetPart(p)
                    if part and part.Position then
                        local dir = part.Position - camPos
                        local dist = dir.Magnitude
                        if dist <= MAX_DISTANCE then
                            local dirNorm = dir.Unit
                            local angle = math.deg(math.acos(math.clamp(camLook:Dot(dirNorm), -1, 1)))
                            if angle <= FOV_DEGREES then
                                if REQUIRE_LOS and not hasLineOfSight(part) then
                                    goto continue
                                end
                                if angle < bestAngle or (math.abs(angle - bestAngle) < 1e-3 and dist < bestDist) then
                                    best = {player = p, part = part}
                                    bestAngle = angle
                                    bestDist = dist
                                end
                            end
                        end
                    end
                end
                ::continue::
            end
            return best
        end

        -- Clean up existing connections
        local function stopAiming()
            if aimConnection then
                aimConnection:Disconnect()
                aimConnection = nil
            end
            if charAddedConn then
                charAddedConn:Disconnect()
                charAddedConn = nil
            end
        end

        -- If toggle is OFF: stop and return
        if not Value then
            stopAiming()
            return
        end

        -- Toggle ON: ensure clean start
        stopAiming()
        -- make sure refs exist
        updateCharacterReferences()

        -- Update camera on respawn
        charAddedConn = localPlayer.CharacterAdded:Connect(function()
            task.wait(0.1)
            updateCharacterReferences()
        end)

        -- Aim loop (disconnects automatically on toggle off)
        aimConnection = RunService.RenderStepped:Connect(function(dt)
            -- guard: if toggle was turned off, stop immediately
            if not Value then
                stopAiming()
                return
            end

            if not camera or not camera.Parent then return end
            local targetInfo = getClosestTargetR6()
            if not targetInfo then return end
            local targetPart = targetInfo.part
            if not targetPart then return end

            local camPos = camera.CFrame.Position
            local aimPos = targetPart.Position

            -- optional prediction
            if PREDICT and BULLET_SPEED and targetPart:IsA("BasePart") then
                local vel = targetPart.AssemblyLinearVelocity or targetPart.Velocity or Vector3.new()
                local t = (aimPos - camPos).Magnitude / BULLET_SPEED
                aimPos = aimPos + vel * t
            end

            local desiredCFrame = CFrame.new(camPos, aimPos)
            local t = math.clamp(1 - math.exp(-SMOOTHNESS * dt), 0, 1)
            -- safe guard in case camera becomes nil mid-frame
            if camera and camera.CFrame then
                camera.CFrame = camera.CFrame:Lerp(desiredCFrame, t)
            end
        end)
   end,
})
