local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Crimson Hub",
   LoadingTitle = "Crimson Hub",
   LoadingSubtitle = "by RACECARGAMING559",
   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Example Hub"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Key System",
      Subtitle = "",
      Note = "Key In Discord Server",
      FileName = "YoutubeHubKey1", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = True, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"SIGMACITY"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})


Window.ModifyTheme('Amethyst')

local MainTab1 = Window:CreateTab("Universal", nil) -- Title, Image
local MainSection = MainTab1:CreateSection("Main")

local MainTab2 = Window:CreateTab("Prison Life", nil) -- Title, Image
local MainSection = MainTab2:CreateSection("Teleports")

local MainTab3 = Window:CreateTab("Murder Mystery 2", nil) -- Title, Image
local MainSection = MainTab3:CreateSection("Main")


local Button = MainTab1:CreateButton({
   Name = "Infinite Jump Toggle",
   Callback = function()
       --Toggles the infinite jump between on or off on every script run
_G.infinjump = not _G.infinjump

if _G.infinJumpStarted == nil then
	--Ensures this only runs once to save resources
	_G.infinJumpStarted = true
	
	--Notifies readiness
	game.StarterGui:SetCore("SendNotification", {Title="Youtube Hub"; Text="Infinite Jump Activated!"; Duration=5;})

	--The actual infinite jump
	local plr = game:GetService('Players').LocalPlayer
	local m = plr:GetMouse()
	m.KeyDown:connect(function(k)
		if _G.infinjump then
			if k:byte() == 32 then
			humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
			humanoid:ChangeState('Jumping')
			wait()
			humanoid:ChangeState('Seated')
			end
		end
	end)
end
   end,
})
local Button = MainTab1:CreateButton({
   Name = "Fly Script",
   Callback = function()
Rayfield:Notify({
   Title = "Notice",
   Content = "Press F to activate, Space to Ascend, LeftControl to Descend",
   Duration = 6.5,
   Image = 4483362458,
})
   	-- FlyScript (LocalScript)
-- Place in StarterPlayer > StarterPlayerScripts
-- Works for dev/testing in your own game

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local cam = workspace.CurrentCamera

-- Config
local TOGGLE_KEY = Enum.KeyCode.F
local ASCEND_KEY = Enum.KeyCode.Space
local DESCEND_KEY = Enum.KeyCode.LeftControl
local MOVE_SPEED = 80         -- studs/second (base)
local ASCEND_SPEED = 60       -- studs/second when holding ascend key
local ACCELERATION = 12       -- higher = snappier velocity changes
local MAX_FORCE = 1e5         -- applied to BodyVelocity / BodyGyro

-- Internal state
local flying = false
local bv, bg
local char, hrp, humanoid
local inputState = {
	forward = 0,
	right = 0,
	up = 0,
}

-- Utility: create flight objects attached to HumanoidRootPart
local function createFlightObjects(root)
	-- BodyVelocity
	local bvInst = Instance.new("BodyVelocity")
	bvInst.MaxForce = Vector3.new(MAX_FORCE, MAX_FORCE, MAX_FORCE)
	bvInst.Velocity = Vector3.new()
	bvInst.P = 1250
	bvInst.Name = "Fly_BodyVelocity"
	bvInst.Parent = root

	-- BodyGyro to stabilize orientation (optional)
	local bgInst = Instance.new("BodyGyro")
	bgInst.MaxTorque = Vector3.new(MAX_FORCE, MAX_FORCE, MAX_FORCE)
	bgInst.P = 3000
	bgInst.D = 50
	bgInst.Name = "Fly_BodyGyro"
	bgInst.Parent = root

	return bvInst, bgInst
end

local function cleanupFlightObjects()
	if bv then
		pcall(function() bv:Destroy() end)
		bv = nil
	end
	if bg then
		pcall(function() bg:Destroy() end)
		bg = nil
	end
end

-- Toggle flying on/off
local function setFlying(state)
	if not char or not hrp or not humanoid then return end
	if state == flying then return end
	flying = state

	if flying then
		-- create objects
		cleanupFlightObjects()
		bv, bg = createFlightObjects(hrp)
		-- optional: reduce humanoid gravity effects by switching state
		-- But avoid fully disabling animations in case you want them.
		-- We'll also disable collisions with PlatformStand approach:
		humanoid.PlatformStand = true
	else
		-- cleanup
		humanoid.PlatformStand = false
		cleanupFlightObjects()
		-- zero out any residual velocity on server (local-only effect mostly)
		hrp.AssemblyLinearVelocity = Vector3.new()
	end
end

-- Input handling (movement axes)
local function onInputBegan(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local k = input.KeyCode
		if k == TOGGLE_KEY then
			setFlying(not flying)
		elseif k == ASCEND_KEY then
			inputState.up = 1
		elseif k == DESCEND_KEY then
			inputState.up = -1
		elseif k == Enum.KeyCode.W or k == Enum.KeyCode.Up then
			inputState.forward = 1
		elseif k == Enum.KeyCode.S or k == Enum.KeyCode.Down then
			inputState.forward = -1
		elseif k == Enum.KeyCode.A or k == Enum.KeyCode.Left then
			inputState.right = -1
		elseif k == Enum.KeyCode.D or k == Enum.KeyCode.Right then
			inputState.right = 1
		end
	end
end

local function onInputEnded(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local k = input.KeyCode
		if k == ASCEND_KEY or k == DESCEND_KEY then
			inputState.up = 0
		elseif k == Enum.KeyCode.W or k == Enum.KeyCode.Up or k == Enum.KeyCode.S or k == Enum.KeyCode.Down then
			inputState.forward = 0
		elseif k == Enum.KeyCode.A or k == Enum.KeyCode.Left or k == Enum.KeyCode.D or k == Enum.KeyCode.Right then
			inputState.right = 0
		end
	end
end

-- Main update loop when flying
local currentVelocity = Vector3.new()
local function onRenderStep(dt)
	if not flying or not hrp or not bv or not bg or not cam then return end

	-- Camera relative move vectors
	local camCFrame = cam.CFrame
	local forward = camCFrame.LookVector
	local right = camCFrame.RightVector

	-- Remove vertical from forward/right to keep horizontal direction based on camera yaw
	forward = Vector3.new(forward.X, 0, forward.Z).Unit
	if forward ~= forward then forward = Vector3.new(0,0,-1) end -- safe fallback
	right = Vector3.new(right.X, 0, right.Z).Unit
	if right ~= right then right = Vector3.new(1,0,0) end

	local moveDir = (forward * inputState.forward) + (right * inputState.right)
	if moveDir.Magnitude > 0 then
		moveDir = moveDir.Unit
	end

	local targetHorizontal = moveDir * MOVE_SPEED
	local verticalSpeed = inputState.up * ASCEND_SPEED
	local target = Vector3.new(targetHorizontal.X, verticalSpeed, targetHorizontal.Z)

	-- Smooth velocity interpolation
	local alpha = math.clamp(ACCELERATION * dt, 0, 1)
	currentVelocity = currentVelocity:Lerp(target, alpha)

	-- Apply to BodyVelocity
	bv.Velocity = currentVelocity

	-- Stabilize rotation to face camera forward (optional)
	local lookDir = CFrame.new(hrp.Position, hrp.Position + camCFrame.LookVector)
	bg.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, lookDir:ToEulerAnglesYXZ())
end

-- Character handling
local function onCharacterAdded(c)
	char = c
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")

	-- Ensure flying off when respawned
	flying = false
	cleanupFlightObjects()

	-- Optional: stop flying on death
	humanoid.Died:Connect(function()
		setFlying(false)
	end)
end

-- Bindings
player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
	onCharacterAdded(player.Character)
end

UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)
RunService:BindToRenderStep("FlyScript_Render", Enum.RenderPriority.Character.Value, onRenderStep)

-- Cleanup on leave / script disable
script.Disabled = false
script.Destroying:Connect(function()
	setFlying(false)
	RunService:UnbindFromRenderStep("FlyScript_Render")
	cleanupFlightObjects()
end)

   end,
})
local Button = MainTab1:CreateButton({
   Name = "Touch Fling GUI",
   Callback = function()
   	-- Touch fling gui
 
-- Gui to Lua (VIP VERSION)
-- Version: 6.9
 
-- Instances:
 
local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local Frame_2 = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local TextButton = Instance.new("TextButton")
 
--Properties:
 
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false
print("sub to BlueCat")
 
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(34, 34, 34)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.388539821, 0, 0.427821517, 0)
Frame.Size = UDim2.new(0, 158, 0, 110)
 
Frame_2.Parent = Frame
Frame_2.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderSizePixel = 0
Frame_2.Size = UDim2.new(0, 158, 0, 25)
 
TextLabel.Parent = Frame_2
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(0.112792775, 0, -0.0151660154, 0)
TextLabel.Size = UDim2.new(0, 121, 0, 26)
TextLabel.Font = Enum.Font.Sarpanch
TextLabel.Text = "Touch Fling"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 255)
TextLabel.TextSize = 25.000
 
TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BorderSizePixel = 0
TextButton.Position = UDim2.new(0.113924049, 0, 0.418181807, 0)
TextButton.Size = UDim2.new(0, 121, 0, 37)
TextButton.Font = Enum.Font.SourceSansItalic
TextButton.Text = "OFF"
TextButton.TextColor3 = Color3.fromRGB(0, 0, 0)
TextButton.TextSize = 20.000
 
-- Scripts:
 
local function IIMAWH_fake_script() -- TextButton.LocalScript 
	local script = Instance.new('LocalScript', TextButton)
 
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
 
	local toggleButton = script.Parent
	local hiddenfling = false
	local flingThread 
	if not ReplicatedStorage:FindFirstChild("juisdfj0i32i0eidsuf0iok") then
		local detection = Instance.new("Decal")
		detection.Name = "juisdfj0i32i0eidsuf0iok"
		detection.Parent = ReplicatedStorage
	end
 
	local function fling()
		local lp = Players.LocalPlayer
		local c, hrp, vel, movel = nil, nil, nil, 0.1
 
		while hiddenfling do
			RunService.Heartbeat:Wait()
			c = lp.Character
			hrp = c and c:FindFirstChild("HumanoidRootPart")
 
			if hrp then
				vel = hrp.Velocity
				hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
				RunService.RenderStepped:Wait()
				hrp.Velocity = vel
				RunService.Stepped:Wait()
				hrp.Velocity = vel + Vector3.new(0, movel, 0)
				movel = -movel
			end
		end
	end
 
	toggleButton.MouseButton1Click:Connect(function()
		hiddenfling = not hiddenfling
		toggleButton.Text = hiddenfling and "ON" or "OFF"
 
		if hiddenfling then
			flingThread = coroutine.create(fling)
			coroutine.resume(flingThread)
		else
			hiddenfling = false
		end
	end)
 
end
coroutine.wrap(IIMAWH_fake_script)()
local function QCJQJL_fake_script() -- Frame.LocalScript 
	local script = Instance.new('LocalScript', Frame)
 
	script.Parent.Active = true
	script.Parent.Draggable = true
end
coroutine.wrap(QCJQJL_fake_script)()
   end,
})
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local forceField -- will hold ForceField instance
local godmodeActive = false


local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

local Input = MainTab1:CreateInput({
    Name = "WalkSpeed",
    CurrentValue = "",
    PlaceholderText = "Enter WalkSpeed",
    RemoveTextAfterFocusLost = false,
    Flag = "WalkSpeedInput",
    Callback = function(Text)
        local speed = tonumber(Text)
        if speed then
            -- Apply the WalkSpeed to the Humanoid
            local char = player.Character
            if char and char:FindFirstChild("Humanoid") then
                char.Humanoid.WalkSpeed = speed
            end
        else
            warn("Invalid number entered for WalkSpeed!")
        end
    end,
})
local player = game.Players.LocalPlayer

local Input = MainTab1:CreateInput({
    Name = "JumpPower",
    CurrentValue = "",
    PlaceholderText = "Enter JumpPower",
    RemoveTextAfterFocusLost = false,
    Flag = "JumpPowerInput",
    Callback = function(Text)
        local jumpPower = tonumber(Text)
        if jumpPower then
            -- Apply JumpPower to your character
            local char = player.Character or player.CharacterAdded:Wait()
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.JumpPower = jumpPower
            end
        else
            warn("Invalid number entered for JumpPower!")
        end

    end,
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local espObjects = {} -- table to store ESP info

local Toggle = MainTab1:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Flag = "ESPNametags",
    Callback = function(Value)
        if Value then
            -- Enable ESP for existing players
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= player and p.Character then
                    local char = p.Character
                    -- Highlight
                    if not espObjects[p] then
                        local highlight = Instance.new("Highlight")
                        highlight.Adornee = char
                        highlight.FillColor = Color3.fromRGB(0, 255, 0)
                        highlight.FillTransparency = 0.5
                        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                        highlight.OutlineTransparency = 0
                        highlight.Parent = game:GetService("CoreGui")

                        -- NameTag
                        local nameTag = Instance.new("BillboardGui")
                        nameTag.Name = "ESPNameTag"
                        nameTag.Adornee = char:FindFirstChild("HumanoidRootPart")
                        nameTag.Size = UDim2.new(0,100,0,40)
                        nameTag.StudsOffset = Vector3.new(0,3,0)
                        nameTag.AlwaysOnTop = true

                        local label = Instance.new("TextLabel")
                        label.Size = UDim2.new(1,0,1,0)
                        label.BackgroundTransparency = 1
                        label.Text = p.Name
                        label.TextColor3 = Color3.fromRGB(0,255,0)
                        label.TextScaled = true
                        label.Font = Enum.Font.SourceSansBold
                        label.Parent = nameTag

                        nameTag.Parent = game:GetService("CoreGui")

                        espObjects[p] = {highlight = highlight, nameTag = nameTag}
                    end
                end
            end

            -- Track new players joining
            Players.PlayerAdded:Connect(function(p)
                if Value and p ~= player then
                    p.CharacterAdded:Connect(function(char)
                        if not espObjects[p] then
                            local highlight = Instance.new("Highlight")
                            highlight.Adornee = char
                            highlight.FillColor = Color3.fromRGB(0, 255, 0)
                            highlight.FillTransparency = 0.5
                            highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                            highlight.OutlineTransparency = 0
                            highlight.Parent = game:GetService("CoreGui")

                            local nameTag = Instance.new("BillboardGui")
                            nameTag.Name = "ESPNameTag"
                            nameTag.Adornee = char:FindFirstChild("HumanoidRootPart")
                            nameTag.Size = UDim2.new(0,100,0,40)
                            nameTag.StudsOffset = Vector3.new(0,3,0)
                            nameTag.AlwaysOnTop = true

                            local label = Instance.new("TextLabel")
                            label.Size = UDim2.new(1,0,1,0)
                            label.BackgroundTransparency = 1
                            label.Text = p.Name
                            label.TextColor3 = Color3.fromRGB(0,255,0)
                            label.TextScaled = true
                            label.Font = Enum.Font.SourceSansBold
                            label.Parent = nameTag

                            nameTag.Parent = game:GetService("CoreGui")

                            espObjects[p] = {highlight = highlight, nameTag = nameTag}
                        end
                    end)
                end
            end)

        else
            -- Disable ESP + NameTags
            for _, objs in pairs(espObjects) do
                if objs.highlight then objs.highlight:Destroy() end
                if objs.nameTag then objs.nameTag:Destroy() end
            end
            espObjects = {}
        end
    end,
})

local player = game.Players.LocalPlayer

-- Set the target location here
local targetPosition = Vector3.new(827, 99, 2242) -- Change this to your desired coordinates

local Button = MainTab2:CreateButton({
    Name = "Teleport to Office",
    Callback = function()
Rayfield:Notify({
   Title = "Notice",
   Content = "Teleporting to office",
   Duration = 6.5,
   Image = 4483362458,
})
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(targetPosition)
            print("Teleported to: ", targetPosition)
        else
            warn("HumanoidRootPart not found!")
        end
    end,
})
local player = game.Players.LocalPlayer

-- Set the target location here
local targetPosition = Vector3.new(-930, 94, 2061) -- Change this to your desired coordinates

local Button = MainTab2:CreateButton({
    Name = "Teleport to Hideout",
    Callback = function()
Rayfield:Notify({
   Title = "Notice",
   Content = "Teleporting to Hideout",
   Duration = 6.5,
   Image = 4483362458,
})
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CFrame = CFrame.new(targetPosition)
            print("Teleported to: ", targetPosition)
        else
            warn("HumanoidRootPart not found!")
        end
    end,
})

local MainSection2 = MainTab2:CreateSection("Police")

local Input = MainTab2:CreateInput({
    Name = "Arrest Player",
    CurrentValue = "",
    PlaceholderText = "Enter player name or display name",
    RemoveTextAfterFocusLost = false,
    Flag = "Input1",
    Callback = function(Text)
        -- Everything runs inside here
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local localPlayer = Players.LocalPlayer

        if Text == "" then return end
        Text = string.lower(Text)

        -- Find by username or display name (partial supported)
        local targetPlayer = nil
        for _, player in pairs(Players:GetPlayers()) do
            local uname = string.lower(player.Name)
            local dname = string.lower(player.DisplayName)
            if uname:find(Text) or dname:find(Text) then
                targetPlayer = player
                break
            end
        end

        if not targetPlayer or targetPlayer == localPlayer then

            return
        end

        -- Wait for humanoid root parts
        local function waitForHRP(player)
            local char = player.Character or player.CharacterAdded:Wait()
            return char:WaitForChild("HumanoidRootPart", 5)
        end

        local localChar = localPlayer.Character or localPlayer.CharacterAdded:Wait()
        local localHRP = localChar:WaitForChild("HumanoidRootPart")

        local origCFrame = localHRP.CFrame

        local targetHRP = waitForHRP(targetPlayer)
        if not targetHRP then
            warn("Target HumanoidRootPart not found.")
            return
        end

        -- Teleport to target for 3 seconds
        local DURATION = 3
        local OFFSET = Vector3.new(0, 0, 5)
        local startTime = tick()

        while tick() - startTime < DURATION do
            if not targetHRP.Parent then break end
            if not localHRP or not localHRP.Parent then break end
            localHRP.CFrame = targetHRP.CFrame * CFrame.new(OFFSET)
            RunService.Heartbeat:Wait()
        end

        -- Return to original location
        if localHRP and localHRP.Parent then
            localHRP.CFrame = origCFrame
        end
    end,
})

local MainSection = MainTab2:CreateSection("Main")



local MainTab4 = Window:CreateTab("Work at a pizza place", nil) -- Title, Image
local MainSection = MainTab4:CreateSection("Main")


local Button = MainTab4:CreateButton({
   Name = "Steal Manager Spot",
   Callback = function()
Rayfield:Notify({
   Title = "Notice",
   Content = "Will automatically teleport to manager's desk",
   Duration = 6.5,
   Image = 4483362458,
})
-- TeleportWhenTeamEmpty.lua
-- LocalScript (client)
-- Teleports the local player to TELEPORT_POSITION when TARGET_TEAM_NAME has no players.
-- Adjust settings below.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TeamsService = game:GetService("Teams") -- optional if you prefer Team objects

local LocalPlayer = Players.LocalPlayer

-- CONFIG:
local TARGET_TEAM_NAME = "Manager" -- team name to watch (case-sensitive)
local TELEPORT_POSITION = Vector3.new(23.58, 4.18, 6.46) -- where to teleport when team is empty
local CHECK_INTERVAL = 1 -- seconds between checks
local DEBOUNCE_TIME = 3 -- seconds to wait after teleport before allowing teleport again (prevents spam)

-- Optional: only teleport if the local player is not already on that team
local SKIP_IF_ON_TARGET_TEAM = true

-- Internal
local lastTeleport = 0

local function getTeamByName(name)
    if not name then return nil end
    for _, t in pairs(TeamsService:GetChildren()) do
        if t:IsA("Team") and t.Name == name then
            return t
        end
    end
    return nil
end

local function teamPlayerCount(team)
    if not team then return 0 end
    local count = 0
    for _, p in pairs(Players:GetPlayers()) do
        if p.Team == team then
            count = count + 1
        end
    end
    return count
end

local function teleportLocalPlayerTo(pos)
    local char = LocalPlayer.Character
    if not char then return false end

    local hrp = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
    if not hrp then return false end

    -- Use SetPrimaryPartCFrame if PrimaryPart exists, otherwise set HRP.CFrame
    if char.PrimaryPart then
        char:SetPrimaryPartCFrame(CFrame.new(pos) * CFrame.new(0, 2, 0)) -- slight upward offset
    else
        hrp.CFrame = CFrame.new(pos) * CFrame.new(0, 2, 0)
    end

    lastTeleport = tick()
    return true
end

-- main loop
spawn(function()
    -- Wait until player and character exist
    while not LocalPlayer do
        wait()
    end

    -- resolve team object if provided by name
    local targetTeam = getTeamByName(TARGET_TEAM_NAME)

    while true do
        local now = tick()

        -- If team object might change (e.g., team created late), keep resolving by name
        if not targetTeam then
            targetTeam = getTeamByName(TARGET_TEAM_NAME)
        end

        -- Optionally skip if local player is on that team
        if SKIP_IF_ON_TARGET_TEAM and targetTeam and LocalPlayer.Team == targetTeam then
            -- do nothing
        else
            local count = teamPlayerCount(targetTeam)
            if count == 0 then
                -- check debounce
                if now - lastTeleport > DEBOUNCE_TIME then
                    local success = teleportLocalPlayerTo(TELEPORT_POSITION)
                    if success then
                        -- optional: notify the local admin player
                        pcall(function()
                            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                                Text = "[AutoTeleport] Team '".. tostring(TARGET_TEAM_NAME) .."' empty. Teleported.";
                                Color = Color3.fromRGB(100, 255, 100);
                                Font = Enum.Font.SourceSansBold;
                                FontSize = Enum.FontSize.Size24;
                            })
                        end)
                    end
                end
            end
        end

        wait(CHECK_INTERVAL)
    end
end)


   end,
})
local Button = MainTab1:CreateButton({
   Name = "Aimbot",
   Callback = function()
 Rayfield:Notify({
   Title = "Notice",
   Content = "Use H to toggle aimbot",
   Duration = 6.5,
   Image = 4483362458,
})

-- Dev Aimbot LocalScript (StarterPlayerScripts)
-- Use only in places you own. Do not abuse.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- ===== CONFIG =====
local ENABLE_KEY = Enum.KeyCode.H   -- toggle key
local ENABLED = false                        -- starts disabled
local FOV_DEGREES = 60                       -- cone to search in degrees
local MAX_DISTANCE = 2000                    -- max target distance
local SMOOTHNESS = 3                     -- higher = slower smoothing (lerp factor per second)
local TEAM_CHECK = true                      -- ignore players on same team
local PREDICT = true                         -- enable linear prediction
local BULLET_SPEED = 200                     -- studs per second (approx) for prediction; set nil to disable prediction
local AIM_AT_HITPART = true                  -- true aims at HumanoidRootPart if present, otherwise PrimaryPart
-- ==================

local function isValidTarget(p)
    if not p or p == localPlayer then return false end
    if not p.Character or not p.Character.Parent then return false end
    local hrp = p.Character:FindFirstChild("HumanoidRootPart") or p.Character.PrimaryPart
    if not hrp then return false end
    -- team check
    if TEAM_CHECK then
        local myTeam = localPlayer.Team
        if myTeam and p.Team == myTeam then
            return false
        end
    end
    return true
end

local function getTargetPosition(target)
    if not target or not target.Character then return nil end
    local part
    if AIM_AT_HITPART then
        part = target.Character:FindFirstChild("HumanoidRootPart") or target.Character.PrimaryPart
    else
        part = target.Character.PrimaryPart or target.Character:FindFirstChild("HumanoidRootPart")
    end
    if not part then return nil end
    return part.Position, part
end

local function predictPosition(currPos, currVel, originPos, speed)
    -- Simple linear prediction: solve for t where distance(origin, currPos + currVel * t) = speed * t
    -- Quadratic: (currVel·currVel - speed^2) t^2 + 2*(rel·currVel) t + (rel·rel) = 0, where rel = currPos - originPos
    local rel = currPos - originPos
    local a = currVel:Dot(currVel) - (speed * speed)
    local b = 2 * rel:Dot(currVel)
    local c = rel:Dot(rel)
    local discriminant = b*b - 4*a*c
    if a == 0 then
        if b == 0 then return currPos end
        local t = -c / b
        if t > 0 then return currPos + currVel * t else return currPos end
    end
    if discriminant < 0 then
        return currPos -- no valid intercept, fallback
    end
    local sqrtD = math.sqrt(discriminant)
    local t1 = (-b + sqrtD) / (2 * a)
    local t2 = (-b - sqrtD) / (2 * a)
    local t = math.min(t1 > 0 and t1 or math.huge, t2 > 0 and t2 or math.huge)
    if t == math.huge or t <= 0 then
        return currPos
    end
    return currPos + currVel * t
end

local function getClosestTarget()
    local camPos = camera.CFrame.Position
    local camLook = camera.CFrame.LookVector
    local bestTarget, bestAngle, bestDist = nil, math.huge, math.huge

    for _, p in pairs(Players:GetPlayers()) do
        if isValidTarget(p) then
            local pos, part = getTargetPosition(p)
            if pos then
                local dir = (pos - camPos)
                local dist = dir.Magnitude
                if dist <= MAX_DISTANCE then
                    local dirNorm = dir.Unit
                    local angle = math.deg(math.acos(math.clamp(camLook:Dot(dirNorm), -1, 1)))
                    if angle <= FOV_DEGREES then
                        -- prefer smaller angle, then closer
                        if angle < bestAngle or (math.abs(angle - bestAngle) < 1e-3 and dist < bestDist) then
                            bestTarget = {player = p, part = part}
                            bestAngle = angle
                            bestDist = dist
                        end
                    end
                end
            end
        end
    end

    return bestTarget
end

-- Toggle handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == ENABLE_KEY then
        ENABLED = not ENABLED
        -- optional print
        print("DevAimbot:", ENABLED and "Enabled" or "Disabled")
    end
end)

-- Main aim loop on RenderStepped for smooth camera updates
RunService.RenderStepped:Connect(function(dt)
    if not ENABLED then return end
    if not camera or not camera.Parent then return end

    local targetInfo = getClosestTarget()
    if not targetInfo then return end

    local targetPlayer = targetInfo.player
    local targetPart = targetInfo.part
    if not targetPart then return end

    local camPos = camera.CFrame.Position
    local aimPos = targetPart.Position

    -- prediction: try to get velocity of the part if possible
    if PREDICT and BULLET_SPEED and targetPart and targetPart:IsA("BasePart") then
        local vel = Vector3.new(0,0,0)
        local success, humanoid = pcall(function() return targetPlayer.Character and targetPlayer.Character:FindFirstChildOfClass("Humanoid") end)
        -- best-effort: use assembly linear velocity if available
        if targetPart.AssemblyLinearVelocity then
            vel = targetPart.AssemblyLinearVelocity
        elseif targetPart.Velocity then
            vel = targetPart.Velocity
        end
        local predicted = predictPosition(aimPos, vel, camPos, BULLET_SPEED)
        aimPos = predicted
    end

    -- compute desired camera CFrame: keep camera position, look at aimPos
    local desiredCFrame = CFrame.new(camPos, aimPos)

    -- smooth: slerp/lerp the look vector by interpolating CFrames
    -- We'll slerp by t factor based on SMOOTHNESS and dt
    local t = math.clamp(1 - math.exp(-SMOOTHNESS * dt), 0, 1) -- exponential smoothing
    camera.CFrame = camera.CFrame:Lerp(desiredCFrame, t)
end)

-- Optional: Cleanup when player dies / camera resets (not strictly necessary, but helpful)
Players.LocalPlayer.CharacterAdded:Connect(function(char)
    wait(0.1)
    camera = Workspace.CurrentCamera
end)

print("Dev Aimbot loaded. Toggle with", tostring(ENABLE_KEY))

   end,
})
